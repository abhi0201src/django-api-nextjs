name: Promote Environment

on:
  workflow_dispatch:
    inputs:
      source_environment:
        description: 'Source environment to promote from'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
      target_environment:
        description: 'Target environment to promote to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - prod
      source_image_tag:
        description: 'Source image tag to promote (default: latest)'
        required: false
        default: 'latest'
        type: string

env:
  AWS_REGION: us-west-2
  PROJECT_NAME: django-nextjs-app

jobs:
  validate-promotion:
    name: Validate Promotion
    runs-on: ubuntu-latest
    outputs:
      source-env: ${{ steps.validate.outputs.source-env }}
      target-env: ${{ steps.validate.outputs.target-env }}
      image-tag: ${{ steps.validate.outputs.image-tag }}
    
    steps:
    - name: Validate promotion path
      id: validate
      run: |
        SOURCE="${{ github.event.inputs.source_environment }}"
        TARGET="${{ github.event.inputs.target_environment }}"
        TAG="${{ github.event.inputs.source_image_tag }}"
        
        # Validate promotion path
        if [[ "$SOURCE" == "dev" && "$TARGET" == "staging" ]]; then
          echo "âœ… Valid promotion: dev â†’ staging"
        elif [[ "$SOURCE" == "staging" && "$TARGET" == "prod" ]]; then
          echo "âœ… Valid promotion: staging â†’ prod"
        else
          echo "âŒ Invalid promotion path: $SOURCE â†’ $TARGET"
          echo "Valid paths: dev â†’ staging, staging â†’ prod"
          exit 1
        fi
        
        echo "source-env=${SOURCE}" >> $GITHUB_OUTPUT
        echo "target-env=${TARGET}" >> $GITHUB_OUTPUT
        echo "image-tag=${TAG}" >> $GITHUB_OUTPUT

  promote-images:
    name: Promote Docker Images
    runs-on: ubuntu-latest
    needs: validate-promotion
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Promote backend image
      run: |
        SOURCE_ENV="${{ needs.validate-promotion.outputs.source-env }}"
        TARGET_ENV="${{ needs.validate-promotion.outputs.target-env }}"
        IMAGE_TAG="${{ needs.validate-promotion.outputs.image-tag }}"
        REGISTRY="${{ steps.login-ecr.outputs.registry }}"
        
        SOURCE_REPO="${PROJECT_NAME}-${SOURCE_ENV}-backend"
        TARGET_REPO="${PROJECT_NAME}-${TARGET_ENV}-backend"
        
        echo "Promoting backend image from ${SOURCE_ENV} to ${TARGET_ENV}"
        
        # Create target repository if it doesn't exist
        aws ecr describe-repositories --repository-names "${TARGET_REPO}" || \
        aws ecr create-repository --repository-name "${TARGET_REPO}" \
          --image-scanning-configuration scanOnPush=true
        
        # Pull source image
        docker pull "${REGISTRY}/${SOURCE_REPO}:${IMAGE_TAG}"
        
        # Tag for target environment
        PROMOTED_TAG="promoted-$(date +%Y%m%d-%H%M%S)"
        docker tag "${REGISTRY}/${SOURCE_REPO}:${IMAGE_TAG}" "${REGISTRY}/${TARGET_REPO}:${PROMOTED_TAG}"
        docker tag "${REGISTRY}/${SOURCE_REPO}:${IMAGE_TAG}" "${REGISTRY}/${TARGET_REPO}:latest"
        
        # Push to target repository
        docker push "${REGISTRY}/${TARGET_REPO}:${PROMOTED_TAG}"
        docker push "${REGISTRY}/${TARGET_REPO}:latest"
        
        echo "âœ… Backend image promoted successfully"
        echo "BACKEND_PROMOTED_TAG=${PROMOTED_TAG}" >> $GITHUB_ENV

    - name: Promote frontend image
      run: |
        SOURCE_ENV="${{ needs.validate-promotion.outputs.source-env }}"
        TARGET_ENV="${{ needs.validate-promotion.outputs.target-env }}"
        IMAGE_TAG="${{ needs.validate-promotion.outputs.image-tag }}"
        REGISTRY="${{ steps.login-ecr.outputs.registry }}"
        
        SOURCE_REPO="${PROJECT_NAME}-${SOURCE_ENV}-frontend"
        TARGET_REPO="${PROJECT_NAME}-${TARGET_ENV}-frontend"
        
        echo "Promoting frontend image from ${SOURCE_ENV} to ${TARGET_ENV}"
        
        # Create target repository if it doesn't exist
        aws ecr describe-repositories --repository-names "${TARGET_REPO}" || \
        aws ecr create-repository --repository-name "${TARGET_REPO}" \
          --image-scanning-configuration scanOnPush=true
        
        # Pull source image
        docker pull "${REGISTRY}/${SOURCE_REPO}:${IMAGE_TAG}"
        
        # Tag for target environment
        PROMOTED_TAG="promoted-$(date +%Y%m%d-%H%M%S)"
        docker tag "${REGISTRY}/${SOURCE_REPO}:${IMAGE_TAG}" "${REGISTRY}/${TARGET_REPO}:${PROMOTED_TAG}"
        docker tag "${REGISTRY}/${SOURCE_REPO}:${IMAGE_TAG}" "${REGISTRY}/${TARGET_REPO}:latest"
        
        # Push to target repository
        docker push "${REGISTRY}/${TARGET_REPO}:${PROMOTED_TAG}"
        docker push "${REGISTRY}/${TARGET_REPO}:latest"
        
        echo "âœ… Frontend image promoted successfully"
        echo "FRONTEND_PROMOTED_TAG=${PROMOTED_TAG}" >> $GITHUB_ENV

  deploy-promoted:
    name: Deploy Promoted Images
    runs-on: ubuntu-latest
    needs: [validate-promotion, promote-images]
    environment: ${{ needs.validate-promotion.outputs.target-env }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Create terraform.tfvars for target environment
      run: |
        TARGET_ENV="${{ needs.validate-promotion.outputs.target-env }}"
        
        # Set environment-specific configurations
        if [[ "$TARGET_ENV" == "prod" ]]; then
          CPU_THRESHOLD=85
          MEMORY_THRESHOLD=85
          MIN_TASKS=2
          RESPONSE_TIME=1.5
          ERROR_THRESHOLD=5
        else
          CPU_THRESHOLD=80
          MEMORY_THRESHOLD=80
          MIN_TASKS=1
          RESPONSE_TIME=2.0
          ERROR_THRESHOLD=10
        fi
        
        cat > terraform/terraform.tfvars <<EOF
        aws_region = "${{ env.AWS_REGION }}"
        project_name = "${{ env.PROJECT_NAME }}"
        environment = "${TARGET_ENV}"
        
        backend_environment_variables = {
          DEBUG = "False"
          ENVIRONMENT = "${TARGET_ENV}"
        }
        
        default_tags = {
          Project     = "${{ env.PROJECT_NAME }}"
          Environment = "${TARGET_ENV}"
          ManagedBy   = "github-actions-promotion"
          SourceEnv   = "${{ needs.validate-promotion.outputs.source-env }}"
          GitCommit   = "${{ github.sha }}"
        }
        
        # Monitoring Configuration
        alert_email_addresses = [
          "${{ secrets.ALERT_EMAIL }}"
        ]
        
        # CloudWatch Alarm Thresholds
        cpu_threshold_high     = ${CPU_THRESHOLD}
        memory_threshold_high  = ${MEMORY_THRESHOLD}
        min_running_tasks      = ${MIN_TASKS}
        response_time_threshold = ${RESPONSE_TIME}
        error_5xx_threshold    = ${ERROR_THRESHOLD}
        
        # Dashboard and Custom Metrics
        enable_dashboard      = true
        enable_custom_metrics = false
        EOF

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan -out=tfplan

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve tfplan

    - name: Update ECS Services
      run: |
        TARGET_ENV="${{ needs.validate-promotion.outputs.target-env }}"
        CLUSTER_NAME="${{ env.PROJECT_NAME }}-${TARGET_ENV}"
        
        echo "Updating ECS services to use promoted images..."
        
        # Update backend service
        aws ecs update-service \
          --cluster ${CLUSTER_NAME} \
          --service "${{ env.PROJECT_NAME }}-${TARGET_ENV}-backend" \
          --force-new-deployment
        
        # Update frontend service
        aws ecs update-service \
          --cluster ${CLUSTER_NAME} \
          --service "${{ env.PROJECT_NAME }}-${TARGET_ENV}-frontend" \
          --force-new-deployment

    - name: Wait for deployment
      run: |
        TARGET_ENV="${{ needs.validate-promotion.outputs.target-env }}"
        CLUSTER_NAME="${{ env.PROJECT_NAME }}-${TARGET_ENV}"
        
        echo "Waiting for services to stabilize..."
        
        aws ecs wait services-stable \
          --cluster ${CLUSTER_NAME} \
          --services "${{ env.PROJECT_NAME }}-${TARGET_ENV}-backend"
        
        aws ecs wait services-stable \
          --cluster ${CLUSTER_NAME} \
          --services "${{ env.PROJECT_NAME }}-${TARGET_ENV}-frontend"

    - name: Health check promoted deployment
      run: |
        cd terraform
        ALB_DNS=$(terraform output -raw alb_dns_name)
        
        echo "Testing promoted deployment health..."
        for i in {1..5}; do
          if curl -f -s "http://${ALB_DNS}/health/" > /dev/null; then
            echo "âœ… Promoted deployment health check passed!"
            break
          else
            echo "â³ Health check attempt $i failed, retrying in 30 seconds..."
            sleep 30
          fi
          
          if [ $i -eq 5 ]; then
            echo "âŒ Promoted deployment health check failed"
            exit 1
          fi
        done

    - name: Create promotion summary
      run: |
        SOURCE_ENV="${{ needs.validate-promotion.outputs.source-env }}"
        TARGET_ENV="${{ needs.validate-promotion.outputs.target-env }}"
        IMAGE_TAG="${{ needs.validate-promotion.outputs.image-tag }}"
        
        cd terraform
        ALB_DNS=$(terraform output -raw alb_dns_name)
        
        cat >> $GITHUB_STEP_SUMMARY <<EOF
        # ðŸš€ Environment Promotion Successful!
        
        **Promotion Path:** ${SOURCE_ENV} â†’ ${TARGET_ENV}
        **Source Image Tag:** ${IMAGE_TAG}
        **Git Commit:** ${{ github.sha }}
        **Promotion Date:** $(date -u)
        
        ## ðŸ”— Application URLs
        - **Main App:** http://${ALB_DNS}
        - **API:** http://${ALB_DNS}/api/
        - **Admin:** http://${ALB_DNS}/admin/
        - **Health:** http://${ALB_DNS}/health/
        
        ## ðŸ“Š Monitoring
        - **CloudWatch Dashboard:** Available in AWS Console
        - **Environment:** ${TARGET_ENV}
        
        **Promotion completed successfully!**
        EOF

  notify-promotion:
    name: Notify Promotion
    runs-on: ubuntu-latest
    needs: [validate-promotion, promote-images, deploy-promoted]
    if: always()
    
    steps:
    - name: Notify success
      if: needs.deploy-promoted.result == 'success'
      run: |
        SOURCE_ENV="${{ needs.validate-promotion.outputs.source-env }}"
        TARGET_ENV="${{ needs.validate-promotion.outputs.target-env }}"
        echo "ðŸŽ‰ Successfully promoted from ${SOURCE_ENV} to ${TARGET_ENV}!"
    
    - name: Notify failure
      if: needs.promote-images.result == 'failure' || needs.deploy-promoted.result == 'failure'
      run: |
        SOURCE_ENV="${{ needs.validate-promotion.outputs.source-env }}"
        TARGET_ENV="${{ needs.validate-promotion.outputs.target-env }}"
        echo "âŒ Failed to promote from ${SOURCE_ENV} to ${TARGET_ENV}!"
        exit 1
