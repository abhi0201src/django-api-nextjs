name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - promote
          - cleanup
          - health-check
      environment:
        description: 'Environment to target'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      source_environment:
        description: 'Source environment (for promotion)'
        required: false
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
      target_environment:
        description: 'Target environment (for promotion)'
        required: false
        default: 'staging'
        type: choice
        options:
          - staging
          - prod
      confirm_destroy:
        description: 'Type DESTROY to confirm cleanup'
        required: false
        default: ''
        type: string
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-west-2
  PROJECT_NAME: django-nextjs-app

jobs:
  # Job 1: Test and Build
  test-and-build:
    name: Test and Build
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      backend-image: ${{ steps.build-info.outputs.backend-image }}
      frontend-image: ${{ steps.build-info.outputs.frontend-image }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set environment
      id: set-env
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "environment=prod" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
        else
          echo "environment=dev" >> $GITHUB_OUTPUT
        fi

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: menu-frontend/package-lock.json

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Install Node.js dependencies
      run: |
        cd menu-frontend
        npm ci

    - name: Run Django tests
      run: |
        python manage.py test
      env:
        DEBUG: False

    - name: Run Django security check
      run: |
        pip install bandit safety
        bandit -r . -x ./venv/,./node_modules/
        safety check

    - name: Build Next.js frontend
      run: |
        cd menu-frontend
        npm run build

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set build info
      id: build-info
      run: |
        ENVIRONMENT=${{ steps.set-env.outputs.environment }}
        REGISTRY=${{ steps.login-ecr.outputs.registry }}
        BACKEND_IMAGE=${REGISTRY}/${PROJECT_NAME}-${ENVIRONMENT}-backend:${{ github.sha }}
        FRONTEND_IMAGE=${REGISTRY}/${PROJECT_NAME}-${ENVIRONMENT}-frontend:${{ github.sha }}
        echo "backend-image=${BACKEND_IMAGE}" >> $GITHUB_OUTPUT
        echo "frontend-image=${FRONTEND_IMAGE}" >> $GITHUB_OUTPUT

    - name: Create ECR repositories if they don't exist
      run: |
        ENVIRONMENT=${{ steps.set-env.outputs.environment }}
        
        # Create backend repository
        aws ecr describe-repositories --repository-names "${PROJECT_NAME}-${ENVIRONMENT}-backend" || \
        aws ecr create-repository --repository-name "${PROJECT_NAME}-${ENVIRONMENT}-backend" \
          --image-scanning-configuration scanOnPush=true
        
        # Create frontend repository
        aws ecr describe-repositories --repository-names "${PROJECT_NAME}-${ENVIRONMENT}-frontend" || \
        aws ecr create-repository --repository-name "${PROJECT_NAME}-${ENVIRONMENT}-frontend" \
          --image-scanning-configuration scanOnPush=true

    - name: Build and push backend Docker image
      run: |
        docker build -t ${{ steps.build-info.outputs.backend-image }} .
        docker push ${{ steps.build-info.outputs.backend-image }}
        
        # Also tag as latest for the environment
        ENVIRONMENT=${{ steps.set-env.outputs.environment }}
        REGISTRY=${{ steps.login-ecr.outputs.registry }}
        LATEST_TAG=${REGISTRY}/${PROJECT_NAME}-${ENVIRONMENT}-backend:latest
        docker tag ${{ steps.build-info.outputs.backend-image }} ${LATEST_TAG}
        docker push ${LATEST_TAG}

    - name: Build and push frontend Docker image
      run: |
        docker build -t ${{ steps.build-info.outputs.frontend-image }} -f menu-frontend/Dockerfile.frontend menu-frontend/
        docker push ${{ steps.build-info.outputs.frontend-image }}
        
        # Also tag as latest for the environment
        ENVIRONMENT=${{ steps.set-env.outputs.environment }}
        REGISTRY=${{ steps.login-ecr.outputs.registry }}
        LATEST_TAG=${REGISTRY}/${PROJECT_NAME}-${ENVIRONMENT}-frontend:latest
        docker tag ${{ steps.build-info.outputs.frontend-image }} ${LATEST_TAG}
        docker push ${LATEST_TAG}

  # Job 2: Deploy Infrastructure
  deploy:
    name: Deploy to ${{ needs.test-and-build.outputs.environment }}
    runs-on: ubuntu-latest
    needs: test-and-build
    if: github.event_name != 'pull_request'
    environment: ${{ needs.test-and-build.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Create terraform.tfvars
      run: |
        ENVIRONMENT=${{ needs.test-and-build.outputs.environment }}
        
        # Set environment-specific configurations
        if [[ "$ENVIRONMENT" == "prod" ]]; then
          CPU_THRESHOLD=85
          MEMORY_THRESHOLD=85
          MIN_TASKS=2
          RESPONSE_TIME=1.5
          ERROR_THRESHOLD=5
          BACKEND_CPU=512
          BACKEND_MEMORY=1024
          FRONTEND_CPU=256
          FRONTEND_MEMORY=512
          DESIRED_BACKEND=3
          DESIRED_FRONTEND=3
        elif [[ "$ENVIRONMENT" == "staging" ]]; then
          CPU_THRESHOLD=80
          MEMORY_THRESHOLD=80
          MIN_TASKS=1
          RESPONSE_TIME=2.0
          ERROR_THRESHOLD=10
          BACKEND_CPU=256
          BACKEND_MEMORY=512
          FRONTEND_CPU=256
          FRONTEND_MEMORY=512
          DESIRED_BACKEND=2
          DESIRED_FRONTEND=2
        else
          CPU_THRESHOLD=80
          MEMORY_THRESHOLD=80
          MIN_TASKS=1
          RESPONSE_TIME=2.0
          ERROR_THRESHOLD=10
          BACKEND_CPU=256
          BACKEND_MEMORY=512
          FRONTEND_CPU=256
          FRONTEND_MEMORY=512
          DESIRED_BACKEND=1
          DESIRED_FRONTEND=1
        fi
        
        cat > terraform/terraform.tfvars <<EOF
        aws_region = "${{ env.AWS_REGION }}"
        project_name = "${{ env.PROJECT_NAME }}"
        environment = "${ENVIRONMENT}"
        
        backend_environment_variables = {
          DEBUG = "False"
          ENVIRONMENT = "${ENVIRONMENT}"
        }
        
        default_tags = {
          Project     = "${{ env.PROJECT_NAME }}"
          Environment = "${ENVIRONMENT}"
          ManagedBy   = "github-actions"
          GitCommit   = "${{ github.sha }}"
        }
        
        # Monitoring Configuration
        alert_email_addresses = [
          "${{ secrets.ALERT_EMAIL }}"
        ]
        
        # CloudWatch Alarm Thresholds
        cpu_threshold_high     = ${CPU_THRESHOLD}
        memory_threshold_high  = ${MEMORY_THRESHOLD}
        min_running_tasks      = ${MIN_TASKS}
        response_time_threshold = ${RESPONSE_TIME}
        error_5xx_threshold    = ${ERROR_THRESHOLD}
        
        # Dashboard and Custom Metrics
        enable_dashboard      = true
        enable_custom_metrics = false
        EOF

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Terraform Plan
      id: plan
      run: |
        cd terraform
        terraform plan -out=tfplan -no-color
      continue-on-error: true

    - name: Update Pull Request with Plan
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const output = `#### Terraform Plan 📖\`${{ steps.plan.outcome }}\`
          
          <details><summary>Show Plan</summary>
          
          \`\`\`terraform
          ${{ steps.plan.outputs.stdout }}
          \`\`\`
          
          </details>
          
          *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })

    - name: Terraform Plan Status
      if: steps.plan.outcome == 'failure'
      run: exit 1

    - name: Terraform Apply
      if: github.event_name != 'pull_request'
      run: |
        cd terraform
        terraform apply -auto-approve tfplan

    - name: Get Terraform Outputs
      if: github.event_name != 'pull_request'
      id: terraform-outputs
      run: |
        cd terraform
        echo "alb-dns=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT
        echo "application-url=$(terraform output -raw application_url)" >> $GITHUB_OUTPUT
        echo "api-url=$(terraform output -raw api_url)" >> $GITHUB_OUTPUT

    - name: Update ECS Services with new images
      if: github.event_name != 'pull_request'
      run: |
        ENVIRONMENT=${{ needs.test-and-build.outputs.environment }}
        CLUSTER_NAME="${{ env.PROJECT_NAME }}-${ENVIRONMENT}"
        
        # Update backend service
        aws ecs update-service \
          --cluster ${CLUSTER_NAME} \
          --service "${{ env.PROJECT_NAME }}-${ENVIRONMENT}-backend" \
          --force-new-deployment
        
        # Update frontend service
        aws ecs update-service \
          --cluster ${CLUSTER_NAME} \
          --service "${{ env.PROJECT_NAME }}-${ENVIRONMENT}-frontend" \
          --force-new-deployment

    - name: Wait for deployment to complete
      if: github.event_name != 'pull_request'
      run: |
        ENVIRONMENT=${{ needs.test-and-build.outputs.environment }}
        CLUSTER_NAME="${{ env.PROJECT_NAME }}-${ENVIRONMENT}"
        
        echo "Waiting for backend service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${CLUSTER_NAME} \
          --services "${{ env.PROJECT_NAME }}-${ENVIRONMENT}-backend"
        
        echo "Waiting for frontend service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${CLUSTER_NAME} \
          --services "${{ env.PROJECT_NAME }}-${ENVIRONMENT}-frontend"

  # Job 3: Health Check
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [test-and-build, deploy]
    if: github.event_name != 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Get ALB DNS name
      id: get-alb
      run: |
        cd terraform
        ALB_DNS=$(terraform output -raw alb_dns_name)
        echo "alb-dns=${ALB_DNS}" >> $GITHUB_OUTPUT

    - name: Health check
      run: |
        ALB_DNS=${{ steps.get-alb.outputs.alb-dns }}
        
        echo "Testing health endpoint..."
        for i in {1..10}; do
          if curl -f -s "http://${ALB_DNS}/health/" > /dev/null; then
            echo "✅ Health check passed!"
            break
          else
            echo "⏳ Attempt $i failed, retrying in 30 seconds..."
            sleep 30
          fi
          
          if [ $i -eq 10 ]; then
            echo "❌ Health check failed after 10 attempts"
            exit 1
          fi
        done
        
        echo "Testing frontend..."
        if curl -f -s "http://${ALB_DNS}/" > /dev/null; then
          echo "✅ Frontend is accessible!"
        else
          echo "❌ Frontend is not accessible"
          exit 1
        fi

    - name: Create deployment summary
      run: |
        ENVIRONMENT=${{ needs.test-and-build.outputs.environment }}
        ALB_DNS=${{ steps.get-alb.outputs.alb-dns }}
        
        cat >> $GITHUB_STEP_SUMMARY <<EOF
        # 🚀 Deployment Successful!
        
        **Environment:** ${ENVIRONMENT}
        **Git Commit:** ${{ github.sha }}
        **Docker Images:**
        - Backend: ${{ needs.test-and-build.outputs.backend-image }}
        - Frontend: ${{ needs.test-and-build.outputs.frontend-image }}
        
        ## 🔗 Application URLs
        - **Main App:** http://${ALB_DNS}
        - **API:** http://${ALB_DNS}/api/
        - **Admin:** http://${ALB_DNS}/admin/
        - **Health:** http://${ALB_DNS}/health/
        
        ## 📊 Monitoring
        - **CloudWatch Dashboard:** Available in AWS Console
        - **Alerts:** Configured for abnormal metrics
        
        **Deployment completed at:** $(date -u)
        EOF

  # Job 4: Notify
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [test-and-build, deploy, health-check]
    if: always() && github.event_name != 'pull_request'
    
    steps:
    - name: Notify on success
      if: needs.health-check.result == 'success'
      run: |
        echo "🎉 Deployment to ${{ needs.test-and-build.outputs.environment }} completed successfully!"
    
    - name: Notify on failure
      if: needs.deploy.result == 'failure' || needs.health-check.result == 'failure'
      run: |
        echo "❌ Deployment to ${{ needs.test-and-build.outputs.environment }} failed!"
        exit 1
